"""
Small library for running selenium tests by defining interactions and assertions as a state-machine.

Interactions to be performed with the browser are represented by transitions.
Assertions are represented by states.
"""

from selenium import webdriver
from selenium.webdriver.firefox.options import Options
import traceback


class StateMachineCollection(object):
    """
    Contains a list of StateMachine instances.
    Handles executing state machines and organising the results.
    """

    def __init__(self, machines):
        """
        Set up the initial list of state machines.
        """
        if type(machines) is list:
            self._state_machines = machines
        else:
            raise Exception("State machines must be given as a list instance.")

    def add_state_machine(self, machine):
        if type(machine) is StateMachine:
            self._state_machines.append(machine)
        else:
            raise Exception("Element to add to collection must be a StateMachine instance.")

    def run(self):
        """
        Execute each state machine and collect results.
        """
        for machine in self._state_machines:
            machine.run()


class StateMachineTransition(object):
    """
    Models a state machine transition.
    """

    def __init__(self, source_state, transition_function, guard=None):
        self._state_sequence_instance = None
        self._source_state = source_state
        self._target_state = None
        self._transition_function = transition_function
        self._guard = guard

    def __repr__(self):
        return "<StateMachineTransition %s>" % self._transition_function

    def get_function(self):
        return self._transition_function

    def get_guard(self):
        return self._guard

    def evaluate_guard(self, state_sequence_instance):
        """
        Evaluate this transition's guard with respect to a state sequence instance.
        """
        return self._guard(state_sequence_instance) if self._guard else True

    def execute(self, state_sequence_instance):
        """
        Execute self._transition_function to transform the state held in the state sequence instance,
        ready for assertions by the target state.
        """
        print("Executing transition function '%s'" % self._transition_function.__name__)
        return self._transition_function(state_sequence_instance)

    def set_target_state(self, obj):
        """
        Set the state that this transition should put the execution in.
        """
        if type(obj) is not StateMachineState and callable(obj):
            # we've been given a function, so wrap it in a state object
            obj = StateMachineState(obj)
        self._target_state = obj
        return obj

    def get_target_state(self):
        return self._target_state


class StateMachineState(object):
    """
    Models a state machine state.
    """

    def __init__(self, assertion_function):
        self._state_sequence_instance = None
        self._assertion_function = assertion_function
        self._outgoing_transitions = []

    def __repr__(self):
        return "<StateMachineState %s>" % str(self._assertion_function)

    def get_function(self):
        return self._assertion_function

    def execute(self, state_sequence_instance):
        """
        Execute self._assertion_function to perform assertions on the state generated by the incoming transition.
        """
        print("...checking result with function '%s'..." % self._assertion_function.__name__)
        result = self._assertion_function(state_sequence_instance)
        print("...no failures")
        return result

    def add_outgoing_transition(self, obj, guard=None):
        """
        Add a transition to follow out of the state.
        """
        if guard and not callable(guard):
            raise Exception("Guard supplied to transition must be callable.")
        if type(obj) is not StateMachineTransition and callable(obj):
            # we've been given a function, so wrap it in a transition object
            obj = StateMachineTransition(self, obj, guard=guard)
        self._outgoing_transitions.append(obj)
        return obj

    def get_outgoing_transitions(self):
        return self._outgoing_transitions


class StateMachineStore(object):
    """
    Models a single state machine's data store for data shared across states and transitions.
    """

    def __init__(self):
        self._data = {}

    def put(self, key, value):
        self._data[key] = value

    def get(self, key):
        return self._data.get(key)


class StateMachine(object):
    """
    Models a single state machine.
    """

    def __init__(self):
        """
        Set up the initial configuration of the state machine.
        """
        self._start_state = StateMachineState(lambda fake_arg : True)
        # when the state machine is run, the first step is to turn it into a list of
        # sequences that can be run one-by-one
        self._execution_sequences = []

    def __repr__(self):
        return "<StateMachine %s>" % self._start_state

    def run(self):
        """
        Run the state machine and display results.
        """
        # populate the list of execution sequences
        self._recurse(self._start_state, [self._start_state])
        # map execution sequence to StateSequence instances
        self._execution_sequences = map(
            lambda (n, sequence) : StateSequence(sequence, n),
            enumerate(self._execution_sequences)
        )
        # execute sequences
        for sequence in self._execution_sequences:
            sequence.execute()

    def _recurse(self, current_state, current_sequence):
        """
        Recurse on the state machine to determine the list of execution sequences that one can take.
        If we encounter a state that is already in the current sequence, then we are in a cycle so we end the sequence.
        Hence, the recursive base case is
            end the current branch of recursion if there are no outgoing transitions, once those which have already
            been traversed have been excluded.
        """
        if len(current_state.get_outgoing_transitions()) == 0:
            # recursive base case
            self._execution_sequences.append(current_sequence)
        else:
            # get all child states of the current state that haven't been encountered
            child_transitions = filter(
                lambda transition : transition.get_target_state() not in current_sequence,
                current_state.get_outgoing_transitions()
            )
            # get all child states that have already been encountered in the current sequence
            already_encountered = filter(
                lambda transition : transition.get_target_state() in current_sequence,
                child_transitions
            )
            # for each child state that is new
            for transition in child_transitions:
                # if there are multiple child states, copy the sequence for that branch of recursion
                # otherwise, use the existing one
                # in both cases append the child state to the sequence
                new_sequence = ([s for s in current_sequence]
                                if len(child_transitions) > 1
                                else current_sequence) + [transition.get_target_state()]
                self._recurse(transition.get_target_state(), new_sequence)

            # for each child state that is not new
            for transition in already_encountered:
                # recursive base case
                # add a copy of the current sequence for each case
                self._execution_sequences.append([s for s in current_sequence])

    def add_state(self, incoming_transition, assertion_function):
        """
        Add a state with the given assertion checking function to the state machine.
        ``incoming_transition``
        Return an instance of the new state so that it can be used to add transitions.
        """

        if not callable(assertion_function):
            raise Exception("Object given as an assertion function for a new state must be callable.")

        new_state = StateMachineState(assertion_function)
        incoming_transition.set_target_state(new_state)
        return new_state

    def add_transition(self, transition_function, source_state=None, target_state=None, guard=None):
        """
        Add a transition with the ``transition_function`` leading out of ``source_state``.
        Return an instance of the new transition so that it can be used to add new states.
        """

        if not callable(transition_function):
            raise Exception("Object given as a function to run during a transition must be callable.")

        if source_state and type(source_state) is not StateMachineState:
            raise Exception("Object given as transition source state must be a StateMachineState instance.")

        if guard and not callable(guard):
            raise Exception("Guard supplied to transition must be callable.")

        if not source_state:
            # if no source state is given, assume the transition is being added
            source_state = self._start_state

        new_transition = StateMachineTransition(source_state, transition_function, guard=guard)
        source_state.add_outgoing_transition(new_transition)
        if target_state:
            new_transition.set_target_state(target_state)
        return new_transition


class StateSequence(object):
    """
    Allows a single sequence of states derived from a state machine to be executed separately from all others.
    """

    def __init__(self, sequence, label):
        # set up driver
        options = Options()
        options.headless = True
        # set up instance variables
        self._driver = webdriver.Firefox(options=options)
        self._store = StateMachineStore()
        self._label = label
        # we are given a sequence of states, so we need to derive the transitions
        # from the state machine
        full_sequence = []
        for (n, state) in enumerate(sequence):
            full_sequence.append(state)
            # find the relevant transition
            if n < len(sequence)-1:
                next_transition = filter(
                    lambda transition : transition.get_target_state() == sequence[n+1],
                    state.get_outgoing_transitions()
                )[0]
                full_sequence.append(next_transition)
            else:
                break
        self._sequence = full_sequence

    def __repr__(self):
        return " -> ".join(
            map(
                lambda element : element.get_function().__name__,
                filter(lambda element : type(element) is StateMachineTransition, self._sequence)
            )[1:]
        )

    def driver(self):
        """
        Gets the browser driver associated with this sequence.
        """
        return self._driver

    def store(self):
        """
        Gets the dictionary used for storing data globally in the sequence.
        """
        return self._store

    def get_sequence(self):
        return self._sequence

    def execute(self):
        """
        Execute the sequence of states/transitions.
        """
        print("-- Executing sequence %s --\n" % str(self))
        # execute all elements' functions, missing out the first empty state
        for element in self._sequence[1:]:
            # first, if the element is a transition, check it's guard
            if type(element) is StateMachineTransition and element.get_guard():
                if not element.evaluate_guard(self):
                    # if the guard fails, stop executing this sequence
                    print("Guard on function '%s' gave False, so stopping execution." % element.get_function().__name__)
                    break
                else:
                    print("Guard on function '%s' gave True, so continuing with execution." %
                          element.get_function().__name__)
            # execute the element's function with this state sequence object
            try:
                element.execute(self)
            except AssertionError as e:
                print("Failure:")
                traceback.print_exc()
        print("\n")
